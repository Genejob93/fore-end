[TOC]

# JS 高级

# JS 中的栈和堆内存

```js
# 栈 VS 堆
区别:
	1. JS 中的占内存 和 堆内存, 可以类比于 计算器的 内存和硬盘
  2. 栈内存的空间小(类比于内存). 堆空间相对较大(可以类比于硬盘)
	3. 栈和堆本质都是内存. 临时存储
	4. 栈内存: 程序执行完释放. 
  	>-1. 全局代码执行完释放内存.(关闭浏览器)
		>-2. 函数代码执行完(即: 函数的调用结束)

	5. 堆内存: 堆内存是通过 GC 去定期回收的. 
  6. 栈内存的空间利用率高, 因为释放内存的效率高.
  7. 所有的变量和基本数据类型,保存在栈内存中
	8. 所有的引用数据类型的值, 保存在堆内存中.
```



# 

# 执行上下文

```js
# JS 中执行上下文:
	JS 引擎在JS代码正式执行之前先会创建一个执行环境,并进入执行环境
	1. 在执行环境内部, 会创建一个全局的变量对象, 该变量对象用于收集: 变量,  function, 函数的参数 
		- var function
	2. 确认 this 的指向
  3. 创建作用域链
  
# 函数的执行上下文
# JS内存管理: 
	JS 引擎不允许直接操作栈空间, 所以我们每次访问对空间的数据, 先找栈空间, 通过占空间的变量保存的引用地址, 去访问 堆空间
  
# 内存管理三部曲
	1. 分配内存空间
  2. 使用分配的内存空间
  3. 使用完后, 释放分配的内存空间

/**
 * 函数的执行上下文
 *	函数的局部变量都保存在 栈 空间. 
 *	如果某一个变量对应的值是 应用数据类型: 变量保存的是引用地址, 数据保存在堆内存
 *	 函数保证高效的方法:  函数执行完立马释放之前分配该当前函数的栈空间.. 
 */
# -----------------------------------------------------------

##1. 执行上下文环境
	- 先创建执行上下文对象, 
  - 然后进入执行上下文环境
	- 创建作用域链: 
  - 压栈: 将执行上下文对象压栈. 遵循栈数据结构的特点:(先进后出, 后进先出)
##2. 执行上下文对象

##3. 执行上下文栈
  
```



# 

# 作用域, 作用域链, 

```js
# 作用域是什么? 
/**
 * 作用域只是一个概念, 产生的作用域只是函数在定义的时候遵循了一套已有的规范.
 */

# 作用域链又是什么? 
 /**
  * 作用域链是真实存在的.
  * 作用域链: scopeChain
  *		1. 作用域链的数据结构是一个数组
  *		2. 数组中的数据放置的是: 变量对象
  *		3. 作用域链上的每一个节点保存的是   变量对象.
  */
# 作用域链上变量的查找规则
	/**
	 * 变量的查找规则
	 *	1. 变量使用查找的时候, 会先在当前的作用域的  #变量对象# 中去找, 如果有, 则直接使用, 如果没有, 沿着作用域链去找.
	 *	2. 会找到上一级作用域的 #变量对象#
	 *	3. 直到找到全局的变量对象, 如果有, 则使用, 如果还没有 则会报错
	 */
```



# 

# 闭包

```js
# 闭包产生的条件
	/**
	 * 1. 闭包的产生需要有函数嵌套的关系存在. 
	 * 2. 内部的函数引用外部函数的变量.
	 */
# 闭包
	1. 闭包是在内部函数的内存中存储的一个引用地址
  2. 该引用地址指向的是内部函数使用的变量所在的变量对象.
  3. 闭包不是之前认为的延长局部变量的声明周期,  它会延长整个外部函数变量对象的生命周期
	4. 只不过浏览器为了性能优化将不使用的变量从变量对象中清除了.
	
```

# JS宏队列,微队列











# 







